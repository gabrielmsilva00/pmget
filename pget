#!/usr/bin/env bash
set -euo pipefail

VERSION="1.0.0"

BOLD=$(tput bold 2>/dev/null) || BOLD=""
RESET=$(tput sgr0 2>/dev/null) || RESET=""
RED=$(tput setaf 1 2>/dev/null) || RED=""
GREEN=$(tput setaf 2 2>/dev/null) || GREEN=""
YELLOW=$(tput setaf 3 2>/dev/null) || YELLOW=""
CYAN=$(tput setaf 6 2>/dev/null) || CYAN=""

CLI_MODE=false
USE_SUDO=false
declare -a INSTALL_PKGS=()
declare -a REMOVE_PKGS=()
DETECTED_PM=""
STATE_FILE=""

readonly PKG_REGEX='^[a-zA-Z0-9][a-zA-Z0-9.+_-]*$'

cleanup() {
    tput cnorm 2>/dev/null || true
    [[ -n "$STATE_FILE" && -f "$STATE_FILE" ]] && rm -f "$STATE_FILE"
}
trap cleanup EXIT INT

detect_pm() {
    local -a pms=(pkg nala apt dpkg dnf yum pacman zypper apk)
    for pm in "${pms[@]}"; do
        command -v "$pm" &>/dev/null && { DETECTED_PM="$pm"; return 0; }
    done
    echo "${RED}No supported package manager found${RESET}" >&2
    exit 1
}

run_pm() {
    local action="$1"; shift
    local cmd=()
    [[ "$USE_SUDO" == true ]] && cmd+=(sudo)
    
    case "$DETECTED_PM:$action" in
        pkg:install)     cmd+=(pkg install -y "$@") ;;
        pkg:remove)      cmd+=(pkg uninstall -y "$@") ;;
        nala:install)    cmd+=(nala install -y "$@") ;;
        nala:remove)     cmd+=(nala remove -y "$@") ;;
        apt:install)     cmd+=(apt install -y "$@") ;;
        apt:remove)      cmd+=(apt remove -y "$@") ;;
        dpkg:install)    cmd+=(dpkg -i "$@") ;;
        dpkg:remove)     cmd+=(dpkg -r "$@") ;;
        dnf:install)     cmd+=(dnf install -y "$@") ;;
        dnf:remove)      cmd+=(dnf remove -y "$@") ;;
        yum:install)     cmd+=(yum install -y "$@") ;;
        yum:remove)      cmd+=(yum remove -y "$@") ;;
        pacman:install)  cmd+=(pacman -S --noconfirm "$@") ;;
        pacman:remove)   cmd+=(pacman -R --noconfirm "$@") ;;
        zypper:install)  cmd+=(zypper install -y "$@") ;;
        zypper:remove)   cmd+=(zypper remove -y "$@") ;;
        apk:install)     cmd+=(apk add "$@") ;;
        apk:remove)      cmd+=(apk del "$@") ;;
    esac
    "${cmd[@]}"
}

list_available() {
    case "$DETECTED_PM" in
        pkg)      pkg list-all 2>/dev/null | cut -d/ -f1 ;;
        nala|apt) apt-cache pkgnames 2>/dev/null ;;
        dpkg)     dpkg-query -W -f='${Package}\n' 2>/dev/null ;;
        dnf)      dnf repoquery --qf '%{name}' 2>/dev/null ;;
        yum)      yum list available 2>/dev/null | awk 'NR>1{print $1}' | cut -d. -f1 ;;
        pacman)   pacman -Slq 2>/dev/null ;;
        zypper)   zypper packages 2>/dev/null | awk -F'|' 'NR>4{gsub(/ /,"",$3);print $3}' ;;
        apk)      apk search -q 2>/dev/null ;;
    esac | sort -u
}

list_installed() {
    case "$DETECTED_PM" in
        pkg|nala|apt|dpkg) dpkg-query -W -f='${Package}\n' 2>/dev/null ;;
        dnf|yum)  rpm -qa --qf '%{NAME}\n' 2>/dev/null ;;
        pacman)   pacman -Qq 2>/dev/null ;;
        zypper)   rpm -qa --qf '%{NAME}\n' 2>/dev/null ;;
        apk)      apk list -I 2>/dev/null | cut -d' ' -f1 | sed 's/-[0-9].*//' ;;
    esac | sort -u
}

show_info() {
    local pkg="$1"
    echo -e "${BOLD}${CYAN}Package Information:${RESET}\n"
    case "$DETECTED_PM" in
        pkg)      pkg show "$pkg" 2>/dev/null ;;
        nala)     nala show "$pkg" 2>/dev/null ;;
        apt|dpkg) apt show "$pkg" 2>/dev/null ;;
        dnf)      dnf info "$pkg" 2>/dev/null ;;
        yum)      yum info "$pkg" 2>/dev/null ;;
        pacman)   pacman -Si "$pkg" 2>/dev/null || pacman -Qi "$pkg" 2>/dev/null ;;
        zypper)   zypper info "$pkg" 2>/dev/null ;;
        apk)      apk info -a "$pkg" 2>/dev/null ;;
    esac
}

show_help() {
    cat <<EOF
${BOLD}pget${RESET} v${VERSION} - Package Getter

${BOLD}Usage:${RESET}
  pget [options]
  pget -c [-s] -i <pkgs...> -r <pkgs...>

${BOLD}Options:${RESET}
  -c, --cli       CLI mode (direct execution)
  -s, --sudo      Run with sudo
  -i <pkgs>       Packages to install
  -r <pkgs>       Packages to remove
  -v, --version   Show version
  -h, --help      Show help

${BOLD}TUI Controls:${RESET}
  ↑/↓         Navigate packages
  Enter       Select for install / Execute if any selected
  →           Cycle: none → install → remove
  ←           Cycle: none → remove → install
  ?           Toggle package info
  Esc         Exit

${BOLD}States:${RESET}
  ${GREEN}[+]${RESET} Install    ${RED}[-]${RESET} Remove    [ ] None

${BOLD}Supported:${RESET} pkg, nala, apt, dpkg, dnf, yum, pacman, zypper, apk
EOF
    exit 0
}

parse_args() {
    local mode=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--cli)     CLI_MODE=true ;;
            -s|--sudo)    USE_SUDO=true ;;
            -i|--install) mode="i" ;;
            -r|--remove)  mode="r" ;;
            -v|--version) echo "pget v${VERSION}"; exit 0 ;;
            -h|--help)    show_help ;;
            -*)           echo "${RED}Unknown: $1${RESET}" >&2; exit 1 ;;
            *)
                [[ "$1" =~ $PKG_REGEX ]] || { echo "${RED}Invalid package: $1${RESET}" >&2; exit 1; }
                [[ "$mode" == "i" ]] && INSTALL_PKGS+=("$1")
                [[ "$mode" == "r" ]] && REMOVE_PKGS+=("$1")
                ;;
        esac
        shift
    done
}

run_cli() {
    local rc=0
    echo "${BOLD}${CYAN}pget${RESET} (${DETECTED_PM})$( [[ "$USE_SUDO" == true ]] && echo " ${CYAN}[sudo]${RESET}" )"
    echo
    
    # Run removals first
    if [[ ${#REMOVE_PKGS[@]} -gt 0 ]]; then
        echo "${RED}Removing:${RESET} ${REMOVE_PKGS[*]}"
        run_pm remove "${REMOVE_PKGS[@]}" && echo "${GREEN}✓ Done${RESET}" || { echo "${RED}✗ Failed${RESET}"; rc=1; }
        echo
    fi
    
    # Then installations
    if [[ ${#INSTALL_PKGS[@]} -gt 0 ]]; then
        echo "${GREEN}Installing:${RESET} ${INSTALL_PKGS[*]}"
        run_pm install "${INSTALL_PKGS[@]}" && echo "${GREEN}✓ Done${RESET}" || { echo "${RED}✗ Failed${RESET}"; rc=1; }
    fi
    
    [[ ${#INSTALL_PKGS[@]} -eq 0 && ${#REMOVE_PKGS[@]} -eq 0 ]] && {
        echo "${YELLOW}No packages specified${RESET}"
        rc=1
    }
    
    exit $rc
}

# State management: 0=none, 1=install, 2=remove
get_state() {
    grep -E "^$1:" "$STATE_FILE" 2>/dev/null | cut -d: -f2 || echo 0
}

set_state() {
    local pkg="$1" state="$2"
    grep -v "^${pkg}:" "$STATE_FILE" > "${STATE_FILE}.tmp" 2>/dev/null || true
    mv "${STATE_FILE}.tmp" "$STATE_FILE"
    [[ "$state" != "0" ]] && echo "${pkg}:${state}" >> "$STATE_FILE"
}

cycle_forward() {
    local s=$(get_state "$1")
    set_state "$1" $(( (s + 1) % 3 ))
}

cycle_backward() {
    local s=$(get_state "$1")
    set_state "$1" $(( (s + 2) % 3 ))
}

has_selections() {
    [[ -s "$STATE_FILE" ]] && grep -qE ':[12]$' "$STATE_FILE" 2>/dev/null
}

gen_list() {
    local installed_cache="$1"
    while IFS= read -r pkg; do
        [[ -z "$pkg" ]] && continue
        local s=$(get_state "$pkg")
        local marker="[ ]" color=""
        case "$s" in
            1) marker="[+]"; color="$GREEN" ;;
            2) marker="[-]"; color="$RED" ;;
        esac
        local inst=""
        if echo "$installed_cache" | grep -qxF "$pkg"; then
            inst=" ${YELLOW}*${RESET}"
        fi
        echo -e "${color}${BOLD}${marker}${RESET} ${pkg}${inst}"
    done < <(list_available)
}

execute_selections() {
    local install_list=$(grep ':1$' "$STATE_FILE" 2>/dev/null | cut -d: -f1 | tr '\n' ' ')
    local remove_list=$(grep ':2$' "$STATE_FILE" 2>/dev/null | cut -d: -f1 | tr '\n' ' ')
    
    # Build command
    local cmd="pget -c"
    [[ "$USE_SUDO" == true ]] && cmd+=" -s"
    [[ -n "$install_list" ]] && cmd+=" -i $install_list"
    [[ -n "$remove_list" ]] && cmd+=" -r $remove_list"
    
    echo
    echo "${BOLD}${CYAN}══════════════════════════════${RESET}"
    [[ -n "$install_list" ]] && echo "${GREEN}[+] Install:${RESET} $install_list"
    [[ -n "$remove_list" ]] && echo "${RED}[-] Remove:${RESET} $remove_list"
    echo "${BOLD}${CYAN}══════════════════════════════${RESET}"
    echo
    echo "${CYAN}> ${cmd}${RESET}"
    echo
    
    # Execute
    eval "$cmd"
}

run_tui() {
    STATE_FILE=$(mktemp)
    local installed_cache=$(list_installed)
    
    echo "${BOLD}${CYAN}pget${RESET} (${DETECTED_PM})"
    
    while true; do
        tput civis 2>/dev/null || true
        
        local pkg_list=$(gen_list "$installed_cache")
        
        local result
        result=$(fzf --ansi --no-multi \
            --prompt="${GREEN}Package: ${RESET}" \
            --header="Enter: select/exec | ←→: cycle | ?: info | Esc: exit" \
            --preview="$0 --info {2}" \
            --preview-window="top:40%" \
            --bind="?:toggle-preview" \
            --expect="enter,right,left" \
            --info=inline \
            <<< "$pkg_list" < /dev/tty 2>/dev/null) || true
        
        tput cnorm 2>/dev/null || true
        
        local key=$(head -1 <<< "$result")
        local sel=$(tail -1 <<< "$result")
        local pkg=$(awk '{print $2}' <<< "$sel")
        
        # Esc or empty = exit
        [[ -z "$key" && -z "$sel" ]] && { echo "${CYAN}Exit${RESET}"; break; }
        [[ -z "$pkg" ]] && continue
        
        # Validate package name
        [[ "$pkg" =~ $PKG_REGEX ]] || continue
        
        case "$key" in
            enter)
                local current_state=$(get_state "$pkg")
                if [[ "$current_state" == "0" ]]; then
                    # Not selected -> select for install
                    set_state "$pkg" 1
                else
                    # Already has selections -> execute if any
                    if has_selections; then
                        execute_selections
                        break
                    fi
                fi
                ;;
            right)
                cycle_forward "$pkg"
                ;;
            left)
                cycle_backward "$pkg"
                ;;
        esac
    done
}

main() {
    [[ "${1:-}" == "--info" ]] && { detect_pm; show_info "$2"; exit 0; }
    parse_args "$@"
    detect_pm
    
    if [[ "$CLI_MODE" == true ]]; then
        run_cli
    else
        run_tui
    fi
}

main "$@"
