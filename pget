#!/usr/bin/env bash
# pget - Package Getter (https://github.com/gabrielmsilva00/pget)

VERSION="1.1.4"

# Colors
BOLD=$(tput bold 2>/dev/null) || BOLD=""
RESET=$(tput sgr0 2>/dev/null) || RESET=""
RED=$(tput setaf 1 2>/dev/null) || RED=""
GREEN=$(tput setaf 2 2>/dev/null) || GREEN=""
YELLOW=$(tput setaf 3 2>/dev/null) || YELLOW=""
CYAN=$(tput setaf 6 2>/dev/null) || CYAN=""

CLI_MODE=false
USE_SUDO=false
declare -a INSTALL_PKGS=()
declare -a REMOVE_PKGS=()
DETECTED_PM=""
PKG_FILE=""
STATE_FILE=""

cleanup() {
    tput cnorm 2>/dev/null || true
    [[ -f "${PKG_FILE:-}" ]] && rm -f "$PKG_FILE"
    [[ -f "${STATE_FILE:-}" ]] && rm -f "$STATE_FILE"
}
trap cleanup EXIT INT

detect_pm() {
    # Hierarchy: Feature-rich wrappers first, then native engines.
    # This balances power (wrappers) with stability (engines).
    for pm in nala pkg yay paru pikaur apt dnf pacman zypper apk xbps-query; do
        if command -v "$pm" &>/dev/null; then
            DETECTED_PM="$pm"
            PM_PATH=$(command -v "$pm")
            return 0
        fi
    done
    echo "${RED}Error: No supported package manager found.${RESET}" >&2
    exit 1
}

run_pm() {
    local action="$1"; shift; local cmd=()
    [[ "$USE_SUDO" == true ]] && cmd+=(sudo)
    case "$DETECTED_PM:$action" in
        pkg:install)    cmd+=(pkg install -y "$@") ;;
        pkg:remove)     cmd+=(pkg uninstall -y "$@") ;;
        nala:install)   cmd+=(nala install -y "$@") ;;
        nala:remove)    cmd+=(nala remove -y "$@") ;;
        apt:install)    cmd+=(apt install -y "$@") ;;
        apt:remove)     cmd+=(apt remove -y "$@") ;;
        dnf:install)    cmd+=(dnf install -y "$@") ;;
        dnf:remove)     cmd+=(dnf remove -y "$@") ;;
        yum:install)    cmd+=(yum install -y "$@") ;;
        yum:remove)     cmd+=(yum remove -y "$@") ;;
        pacman:install) cmd+=(pacman -S --noconfirm "$@") ;;
        pacman:remove)  cmd+=(pacman -R --noconfirm "$@") ;;
        zypper:install) cmd+=(zypper install -y "$@") ;;
        zypper:remove)  cmd+=(zypper remove -y "$@") ;;
        apk:install)    cmd+=(apk add "$@") ;;
        apk:remove)     cmd+=(apk del "$@") ;;
    esac
    "${cmd[@]}"
}

fetch_packages() {
    case "$DETECTED_PM" in
        pkg|nala|apt) 
            # Use apt-cache search to get descriptions, format: pkg [TAB] pkg - description
            apt-cache search . 2>/dev/null | awk -F' - ' '{print $1 "\t" $0}' | sort -u ;;
        dnf)      dnf repoquery --qf '%{name}\t%{name} - %{summary}' 2>/dev/null ;;
        yum)      yum list available 2>/dev/null | awk 'NR>1 {print $1 "\t" $0}' | cut -d. -f1 ;;
        pacman)   pacman -Slq 2>/dev/null | awk '{print $1 "\t" $1}' ;;
        zypper)   zypper packages 2>/dev/null | awk -F'|' 'NR>4{gsub(/ /,"",$3);print $3 "\t" $3}' ;;
        apk)      apk search -v 2>/dev/null | awk '{print $1 "\t" $0}' | sed 's/ - / /' ;; 
    esac
}

fetch_installed() {
    case "$DETECTED_PM" in
        pkg)      pkg list-installed 2>/dev/null | cut -d/ -f1 ;;
        nala|apt) dpkg-query -W -f='${Package}\n' 2>/dev/null ;;
        dnf|yum)  rpm -qa --queryformat '%{NAME}\n' 2>/dev/null ;;
        pacman)   pacman -Qq 2>/dev/null ;;
        zypper)   rpm -qa --queryformat '%{NAME}\n' 2>/dev/null ;;
        apk)      apk info -q 2>/dev/null ;;
    esac
}

fetch_upgradeable() {
    case "$DETECTED_PM" in
        pkg)      pkg list-upgradable 2>/dev/null | cut -d/ -f1 ;;
        nala|apt) apt list --upgradeable 2>/dev/null | grep '/' | cut -d/ -f1 ;;
        dnf)      dnf list updates -q 2>/dev/null | awk 'NR>1{print $1}' | cut -d. -f1 ;;
        yum)      yum list updates -q 2>/dev/null | awk 'NR>1{print $1}' | cut -d. -f1 ;;
        pacman)   pacman -Quq 2>/dev/null ;;
        zypper)   zypper list-updates 2>/dev/null | awk -F'|' 'NR>4{gsub(/ /,"",$3);print $3}' ;;
        apk)      apk version -u -q 2>/dev/null | cut -d- -f1 ;;
    esac
}

show_info() {
    echo -e "${BOLD}${CYAN}Package Info:${RESET}\n"
    case "$DETECTED_PM" in
        pkg)      pkg show "$1" 2>/dev/null ;;
        nala)     nala show "$1" 2>/dev/null ;;
        apt)      apt show "$1" 2>/dev/null ;;
        dnf)      dnf info "$1" 2>/dev/null ;;
        yum)      yum info "$1" 2>/dev/null ;;
        pacman)   pacman -Si "$1" 2>/dev/null || pacman -Qi "$1" 2>/dev/null ;;
        zypper)   zypper info "$1" 2>/dev/null ;;
        apk)      apk info -a "$1" 2>/dev/null ;;
    esac
}




parse_args() {
    local mode=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--cli)     CLI_MODE=true ;;
            -s|--sudo)    USE_SUDO=true ;;
            -i|--install) mode="i" ;;
            -r|--remove)  mode="r" ;;
            -v|--version) echo "pget v${VERSION}"; exit 0 ;;
            -h|--help)    echo "pget v${VERSION}"; exit 0 ;;
            --info)       detect_pm; show_info "$2"; exit 0 ;;
            *) [[ "$mode" == "i" ]] && INSTALL_PKGS+=("$1"); [[ "$mode" == "r" ]] && REMOVE_PKGS+=("$1") ;;
        esac
        shift
    done
}

run_cli() {
    echo "${BOLD}${CYAN}pget${RESET} (${DETECTED_PM})$([[ "$USE_SUDO" == true ]] && echo " [sudo]")"
    local rc=0
    [[ ${#REMOVE_PKGS[@]} -gt 0 ]] && { echo "${RED}Removing:${RESET} ${REMOVE_PKGS[*]}"; run_pm remove "${REMOVE_PKGS[@]}" || rc=1; echo; }
    [[ ${#INSTALL_PKGS[@]} -gt 0 ]] && { echo "${GREEN}Installing:${RESET} ${INSTALL_PKGS[*]}"; run_pm install "${INSTALL_PKGS[@]}" || rc=1; }
    [[ ${#INSTALL_PKGS[@]} -eq 0 && ${#REMOVE_PKGS[@]} -eq 0 ]] && echo "${YELLOW}No packages selected${RESET}"
    exit $rc
}

# ----------------------------------------------------
# TUI Logic
# ----------------------------------------------------

run_tui() {
    echo -n "${CYAN}Loading packages...${RESET} "
    
    # Create a temp dir for all artifacts
    TMP_DIR=$(mktemp -d)
    PKG_FILE="$TMP_DIR/packages"
    STATE_FILE="$TMP_DIR/state"
    INST_FILE="$TMP_DIR/installed"
    UPGR_FILE="$TMP_DIR/upgradeable"
    HELPER_SCRIPT="$TMP_DIR/helper.sh"
    
    # Cleanup on exit
    trap "rm -rf '$TMP_DIR'; [[ -n \"${st_orig:-}\" ]] && stty \"\$st_orig\" 2>/dev/null; tput cnorm 2>/dev/null || true" EXIT INT
    
    # Sudo Auto-Detection (per user request)
    if [[ $EUID -eq 0 || "$USE_SUDO" == true ]]; then
        USE_SUDO=true
        echo "__SUDO__=true" >> "$STATE_FILE"
    fi
    
    touch "$STATE_FILE" "$INST_FILE" "$UPGR_FILE"
    
    fetch_packages > "$PKG_FILE"
    fetch_installed > "$INST_FILE"
    fetch_upgradeable > "$UPGR_FILE"
    
    if [[ ! -s "$PKG_FILE" ]]; then
        echo " ${RED}Failed!${RESET}"
        exit 1
    fi
    echo " ${GREEN}OK${RESET} ($(wc -l < "$PKG_FILE" | tr -d ' ') items)"

    # Generate Helper Script
    # Part 1: Static Variables (Unquoted Heredoc for Expansion)
    cat > "$HELPER_SCRIPT" <<EOF
#!/usr/bin/env bash
DETECTED_PM="$DETECTED_PM"
PM_PATH="$PM_PATH"

EOF

    # Part 2: Functions and Logic (Quoted Heredoc to protect awk/regex)
    cat >> "$HELPER_SCRIPT" <<'EOF'

_get_state() { grep "^$2=" "$1" 2>/dev/null | cut -d= -f2 || echo 0; }

_set_state() {
    local sf="$1"
    local pkg="$2"
    local val="$3"
    grep -v "^$pkg=" "$sf" > "$sf.tmp" 2>/dev/null || true
    mv "$sf.tmp" "$sf"
    echo "$pkg=$val" >> "$sf"
}

_toggle_sudo() {
    local sf="$1"
    if grep -q "__SUDO__=true" "$sf"; then
        grep -v "__SUDO__=" "$sf" > "$sf.tmp" && mv "$sf.tmp" "$sf"
        echo "false"
    else
        echo "__SUDO__=true" >> "$sf"
        echo "true"
    fi
}

_internal_state_mod() {
    local sf="$1"
    local pkg="$2"
    local dir="$3"
    local s=$(_get_state "$sf" "$pkg")
    
    local new_s=0
    if [[ "$dir" == "next" ]]; then
        new_s=$(( (s + 1) % 3 ))
    elif [[ "$dir" == "prev" ]]; then
        new_s=$(( (s + 2) % 3 ))
    elif [[ "$dir" == "toggle_or_select" ]]; then
         if [[ "$s" == "0" ]]; then new_s=1; else new_s=$(( (s + 1) % 3 )); fi
    fi
    _set_state "$sf" "$pkg" "$new_s"
}
 
_info() {
    local pm_name="$1"
    local pm_path="$2"
    local pkg="$3"
    echo -e "\033[1m\033[36mPackage Information:\033[0m\n"
    
    # Use the optimal command for each tool (wrappers or native)
    case "$pm_name" in
        nala)         "$pm_path" show "$pkg" 2>/dev/null ;;
        pkg)          "$pm_path" show "$pkg" 2>/dev/null ;;
        yay|paru|pikaur) "$pm_path" -Si "$pkg" 2>/dev/null || "$pm_path" -Qi "$pkg" 2>/dev/null ;;
        apt)          "$pm_path" show "$pkg" 2>/dev/null || apt-cache show "$pkg" 2>/dev/null ;;
        dnf|yum)      "$pm_path" info "$pkg" 2>/dev/null ;;
        pacman)       "$pm_path" -Si "$pkg" 2>/dev/null || "$pm_path" -Qi "$pkg" 2>/dev/null ;;
        zypper)       "$pm_path" info "$pkg" 2>/dev/null ;;
        apk)          "$pm_path" search -v -d "$pkg" 2>/dev/null || "$pm_path" info "$pkg" 2>/dev/null ;;
        xbps-query)   "$pm_path" -Ri "$pkg" 2>/dev/null || "$pm_path" -i "$pkg" 2>/dev/null ;;
    esac
}

_internal_gen_list() {
    local pkg_file="$1"
    local state_file="$2"
    local inst_file="$3"
    local upgr_file="$4"
    awk -v state_file="$state_file" -v inst_file="$inst_file" -v upgr_file="$upgr_file" '
    BEGIN {
        sudo_on = 0
        if (state_file != "") {
            while ((getline line < state_file) > 0) {
                split(line, parts, "=")
                if (parts[1] == "__SUDO__" && parts[2] == "true") sudo_on = 1
                if (parts[1] !~ /^__/) state[parts[1]] = parts[2]
            }
            close(state_file)
        }
        if (inst_file != "") {
            while ((getline line < inst_file) > 0) installed[line] = 1
            close(inst_file)
        }
        if (upgr_file != "") {
            while ((getline line < upgr_file) > 0) upgradeable[line] = 1
            close(upgr_file)
        }

        GREEN="\033[32m"; RED="\033[31m"; YELLOW="\033[33m"; BLUE="\033[34m"
        CYAN="\033[36m"; BOLD="\033[1m"; RESET="\033[0m"
        
        # Header and Legends
        printf "%s%s  SUDO: %s%s%s\n", BOLD, CYAN, RESET, BOLD, (sudo_on ? GREEN "ON" : RED "OFF")
        printf "%s%s  KEYS: %s(Tab: Sudo | Space: Select | Enter: Apply)\n", BOLD, CYAN, RESET
        printf "%s%s  SYMBOLS: %s[ ] None  [✓] Inst  [^] Upgr  [+] Add  [-] Rem\n", BOLD, CYAN, RESET
    }
    {
        split($0, arr, "\t")
        pkg = arr[1]; display = (arr[2] == "" ? pkg : arr[2])
        s = state[pkg]; is_inst = installed[pkg]; is_upgr = upgradeable[pkg]
        
        sym = "[ ]"; col = ""; rst = RESET
        
        if (s == "1") { sym = "[+]"; col = BOLD GREEN }
        else if (s == "2") { sym = "[-]"; col = BOLD RED }
        else if (is_upgr) { sym = "[^]"; col = BOLD YELLOW }
        else if (is_inst) { sym = "[✓]"; col = BOLD BLUE }
        
        # Display [sym] pkg-name (hide description, keep for search)
        printf "%s\t%s%s %-s\t%s%s\n", pkg, col, sym, pkg, display, rst
    }
    ' "$pkg_file"
}

case "$1" in
    gen-list)     _internal_gen_list "$2" "$3" "$4" "$5" ;;
    update-state) _internal_state_mod "$2" "$3" "$4" ;;
    toggle-sudo)  _toggle_sudo "$2" ;;
    info)         _info "$DETECTED_PM" "$PM_PATH" "$2" ;;
esac
EOF
    
    # Define Commands using bash to execute the helper script
    # Field 1 is the package ID (always clean), Field 2+ is for display.
    local helper_cmd="bash '$HELPER_SCRIPT'"
    
    local cmd_update_next="$helper_cmd update-state '$STATE_FILE' {1} next"
    local cmd_update_prev="$helper_cmd update-state '$STATE_FILE' {1} prev"
    local cmd_toggle="$helper_cmd update-state '$STATE_FILE' {1} toggle_or_select"
    local cmd_reload="$helper_cmd gen-list '$PKG_FILE' '$STATE_FILE' '$INST_FILE' '$UPGR_FILE'"
    
    local cmd_preview="[[ -n \"{1}\" ]] && bash \"$HELPER_SCRIPT\" info \"{1}\""
    local cmd_sudo_toggle="$helper_cmd toggle-sudo '$STATE_FILE'"

    # Enter Non-canonical mode to prevent escape sequence leakage (per user insight)
    if [[ -t 0 ]]; then
        st_orig=$(stty -g)
        stty -icanon -echo
    fi
    tput civis 2>/dev/null || true
    
    # Initial Generation
    bash "$HELPER_SCRIPT" gen-list "$PKG_FILE" "$STATE_FILE" "$INST_FILE" "$UPGR_FILE" | \
    fzf --ansi --no-multi \
        --prompt="pget> " \
        --delimiter=$'\t' \
        --with-nth=2 \
        --header-lines=3 \
        --tiebreak=begin,length \
        --preview="$cmd_preview" \
        --preview-window="top:40%" \
        --layout=reverse \
        --info=inline \
        --no-bold \
        --bind "right:execute-silent($cmd_update_next)+reload($cmd_reload)" \
        --bind "left:execute-silent($cmd_update_prev)+reload($cmd_reload)" \
        --bind "space:execute-silent($cmd_toggle)+reload($cmd_reload)" \
        --bind "tab:execute-silent($cmd_sudo_toggle)+reload($cmd_reload)" \
        --bind "alt-enter:print-query" \
        > /dev/null
    
    # Reset terminal
    [[ -n "${st_orig:-}" ]] && stty "$st_orig" 2>/dev/null || true
    tput cnorm 2>/dev/null || true
    
    # Post-Loop Execution Logic
    if grep -q "__SUDO__=true" "$STATE_FILE"; then
        USE_SUDO=true
    else
        USE_SUDO=false
    fi

    local inst=$(grep '=1$' "$STATE_FILE" 2>/dev/null | cut -d= -f1 | tr '\n' ' ')
    local rem=$(grep '=2$' "$STATE_FILE" 2>/dev/null | cut -d= -f1 | tr '\n' ' ')
     
    if [[ -z "$inst" && -z "$rem" ]]; then
         echo "${YELLOW}No packages selected${RESET}"
         exit 0
    fi

    echo
    local cmd="pget -c"
    [[ "$USE_SUDO" == true ]] && cmd+=" -s"
    [[ -n "$inst" ]] && cmd+=" -i $inst"
    [[ -n "$rem" ]] && cmd+=" -r $rem"
     
    echo "${CYAN}> Executing...${RESET}"
    eval "$cmd"
    exit 0
}

main() {
    parse_args "$@"
    detect_pm
    [[ "$CLI_MODE" == true ]] && run_cli || run_tui
}

main "$@"
