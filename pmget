#!/usr/bin/env bash
# pmget - Package Manager Getter (https://github.com/gabrielmsilva00/pmget)

VERSION="1.1.8"

# Colors
BOLD=$(tput bold 2>/dev/null) || BOLD=""
RESET=$(tput sgr0 2>/dev/null) || RESET=""
RED=$(tput setaf 1 2>/dev/null) || RED=""
GREEN=$(tput setaf 2 2>/dev/null) || GREEN=""
YELLOW=$(tput setaf 3 2>/dev/null) || YELLOW=""
BLUE=$(tput setaf 4 2>/dev/null) || BLUE=""
CYAN=$(tput setaf 6 2>/dev/null) || CYAN=""
WHITE=$(tput setaf 7 2>/dev/null) || WHITE=""

# ============================================================================
# SELF-INSTALLATION MODE
# When piped or run with --install, pmget installs itself
# Usage: curl -fsSL <url>/pmget | bash [-s -- OPTIONS]
# ============================================================================

PMGET_URL="https://raw.githubusercontent.com/gabrielmsilva00/pmget/main/pmget"

self_install() {
    local install_mode=""
    local need_sudo=false
    local install_dir=""
    local missing_deps=()

    # Parse install arguments
    for arg in "$@"; do
        case "$arg" in
            --root|--usr|--local)
                [[ -n "$install_mode" ]] && { echo "${RED}Error: Only one of --root, --usr, --local allowed${RESET}"; exit 1; }
                install_mode="${arg#--}"
                ;;
            -h|--help)
                echo "pmget self-installer v${VERSION}"
                echo "Usage: curl -fsSL <url>/pmget | bash [-s -- OPTIONS]"
                echo "       pmget --install [--local | --usr | --root]"
                echo ""
                echo "Options:"
                echo "  --local  Install to ~/.local/bin (default)"
                echo "  --usr    Install to /usr/local/bin (requires sudo)"
                echo "  --root   Install to /root/.local/bin (requires sudo)"
                exit 0
                ;;
        esac
    done

    # Set install directory based on mode
    case "${install_mode:-local}" in
        local) install_dir="$HOME/.local/bin" ;;
        usr)   install_dir="/usr/local/bin"; need_sudo=true ;;
        root)  install_dir="/root/.local/bin"; need_sudo=true ;;
    esac

    echo "${BOLD}${BLUE}pmget installer${RESET}"
    echo "${BLUE}Target:${RESET} $install_dir"
    echo

    # Check for existing pmget installation
    local existing_pmget
    existing_pmget=$(command -v pmget 2>/dev/null) || true
    if [[ -n "$existing_pmget" ]]; then
        if grep -q "github.com/gabrielmsilva00/pmget" "$existing_pmget" 2>/dev/null; then
            local current_ver
            current_ver=$(grep "^VERSION=" "$existing_pmget" 2>/dev/null | head -n 1 | cut -d'"' -f2)
            current_ver="${current_ver:-?}"
            if [[ "$current_ver" == "$VERSION" ]]; then
                echo -n "pmget v${VERSION} is already installed. Reinstall? [y/N] "
                local response
                if [[ -c /dev/tty ]]; then
                    read -r -n 1 response < /dev/tty
                else
                    read -r -n 1 response 2>/dev/null || response="n"
                fi

                if [[ ! "$response" =~ ^[yY]$ ]]; then
                    echo
                    exit 0
                fi
                echo
                echo "${WHITE}→${RESET} Reinstalling v${VERSION}..."
            else
                echo "${WHITE}→${RESET} Updating pmget v${current_ver} to v${VERSION}"
            fi
        else
            echo "${YELLOW}⚠${RESET} Different 'pmget' found: $existing_pmget"
            echo "  Will install to: $install_dir/pmget"
        fi
        echo
    fi

    # Check dependencies
    command -v curl &>/dev/null && echo "${GREEN}✓${RESET} curl" || { echo "${RED}✗${RESET} curl (required)"; missing_deps+=("curl"); }
    command -v fzf &>/dev/null && echo "${GREEN}✓${RESET} fzf" || { echo "${RED}✗${RESET} fzf (required)"; missing_deps+=("fzf"); }

    local pm_found=""
    for p in pkg nala apt dpkg dnf yum pacman zypper apk; do
        command -v "$p" &>/dev/null && { pm_found="$p"; echo "${GREEN}✓${RESET} $p"; break; }
    done
    [[ -z "$pm_found" ]] && { echo "${RED}✗${RESET} package manager (pkg/nala/apt/dpkg/dnf/yum/pacman/zypper/apk)"; missing_deps+=("package-manager"); }

    # Exit if missing dependencies
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo
        echo "${RED}Missing dependencies:${RESET} ${missing_deps[*]}"
        echo "Please install them and re-run the installer."
        exit 1
    fi

    echo

    # Download pmget first (before attempting any directory operations)
    local tmpfile
    tmpfile=$(mktemp)
    if ! curl -fsSL -H "Cache-Control: no-cache" "$PMGET_URL" -o "$tmpfile"; then
        echo "${RED}Download failed${RESET}"
        rm -f "$tmpfile"
        exit 1
    fi

    # Verify download
    if [[ ! -s "$tmpfile" ]] || ! grep -q "github.com/gabrielmsilva00/pmget" "$tmpfile"; then
        echo "${RED}Download invalid or corrupted${RESET}"
        rm -f "$tmpfile"
        exit 1
    fi

    # Try to create directory and install
    local install_success=false

    if [[ "$need_sudo" == true ]]; then
        # Try with sudo first
        echo "${WHITE}→${RESET} Attempting install with sudo..."
        if sudo mkdir -p "$install_dir" 2>/dev/null && \
           sudo cp "$tmpfile" "$install_dir/pmget" 2>/dev/null && \
           sudo chmod +x "$install_dir/pmget" 2>/dev/null; then
            install_success=true
        else
            echo "${YELLOW}⚠${RESET} Sudo failed, trying without sudo..."
            need_sudo=false
        fi
    fi

    if [[ "$install_success" == false ]]; then
        # Try without sudo (either as fallback or default)
        if mkdir -p "$install_dir" 2>/dev/null && \
           mv "$tmpfile" "$install_dir/pmget" 2>/dev/null && \
           chmod +x "$install_dir/pmget" 2>/dev/null; then
            install_success=true
        fi
    fi

    # Clean up temp file if still exists
    rm -f "$tmpfile" 2>/dev/null

    if [[ "$install_success" == false ]]; then
        echo "${RED}✗ Installation failed${RESET}"
        echo "  Could not write to: $install_dir"
        echo "  Try: pmget --self-install --local"
        exit 1
    fi

    echo "${GREEN}✓${RESET} Installed to $install_dir/pmget"

    # Add to PATH if needed
    if [[ "$need_sudo" == false && ":$PATH:" != *":$install_dir:"* ]]; then
        local shell_name shell_rc
        shell_name=$(basename "$SHELL")
        case "$shell_name" in
            zsh)  shell_rc="$HOME/.zshrc" ;;
            bash) shell_rc="$HOME/.bashrc" ;;
            *)    shell_rc="$HOME/.profile" ;;
        esac

        local export_line="export PATH=\"\$PATH:$install_dir\""
        if ! grep -qF "$install_dir" "$shell_rc" 2>/dev/null; then
            echo "" >> "$shell_rc"
            echo "# pmget" >> "$shell_rc"
            echo "$export_line" >> "$shell_rc"
            echo "${GREEN}✓${RESET} Added to PATH in $shell_rc"
            echo "${YELLOW}!${RESET} Run: source $shell_rc"
        fi
    fi

    echo -e "\n${GREEN}Done!${RESET} Run: pmget"
    exit 0
}

# Detect if running from pipe (curl | bash) - auto-install mode
# Skip if sentinel is set, or if -v/--version, -h/--help, --info is requested
if [[ -z "$PMGET_INSTALLING" && ! -t 0 && "${BASH_SOURCE[0]}" == "${0}" ]]; then
    local skip_install=false
    for arg in "$@"; do
        case "$arg" in
            -v|--version|-h|--help|--info) skip_install=true; break;;
        esac
    done
    [[ "$skip_install" == false ]] && self_install "$@"
fi

# ============================================================================
# NORMAL PMGET OPERATION
# ============================================================================

CLI_MODE=false
USE_SUDO=false
declare -a INSTALL_PKGS=()
declare -a REMOVE_PKGS=()
DETECTED_PM=""
PKG_FILE=""
STATE_FILE=""

cleanup() {
    tput cnorm 2>/dev/null || true
    [[ -f "${PKG_FILE:-}" ]] && rm -f "$PKG_FILE"
    [[ -f "${STATE_FILE:-}" ]] && rm -f "$STATE_FILE"
}
trap cleanup EXIT INT

detect_pm() {
    for pm in apt dnf pacman zypper apk; do
        if command -v "$pm" &>/dev/null; then
            DETECTED_PM="$pm"
            PM_PATH=$(command -v "$pm")
            return 0
        fi
    done
    echo "${RED}Error: No supported package manager found (apt/dnf/pacman/zypper/apk).${RESET}" >&2
    exit 1
}

run_pm() {
    local action="$1"; shift; local cmd=()
    [[ "$USE_SUDO" == true ]] && cmd+=(sudo)
    case "$DETECTED_PM:$action" in
        apt:install)    cmd+=(apt install -y "$@") ;;
        apt:remove)     cmd+=(apt remove -y "$@") ;;
        dnf:install)    cmd+=(dnf install -y "$@") ;;
        dnf:remove)     cmd+=(dnf remove -y "$@") ;;
        pacman:install) cmd+=(pacman -S --noconfirm "$@") ;;
        pacman:remove)  cmd+=(pacman -R --noconfirm "$@") ;;
        zypper:install) cmd+=(zypper install -y "$@") ;;
        zypper:remove)  cmd+=(zypper remove -y "$@") ;;
        apk:install)    cmd+=(apk add "$@") ;;
        apk:remove)     cmd+=(apk del "$@") ;;
    esac
    "${cmd[@]}"
}

fetch_packages() {
    case "$DETECTED_PM" in
        apt)      apt-cache search . 2>/dev/null | awk -F' - ' '{print $1 "\t\t\t" $0}' | sort -u ;;
        dnf)      dnf repoquery --qf '%{name}\t\t\t%{name} - %{summary}' 2>/dev/null ;;
        pacman)   pacman -Slq 2>/dev/null | awk '{print $1 "\t\t\t" $1}' ;;
        zypper)   zypper packages 2>/dev/null | awk -F'|' 'NR>4{gsub(/ /,"",$3);print $3 "\t\t\t" $3}' ;;
        apk)      apk search -v 2>/dev/null | awk '{print $1 "\t\t\t" $0}' | sed 's/ - / /' ;;
    esac
}

fetch_installed() {
    case "$DETECTED_PM" in
        apt)      dpkg-query -W -f='${Package}\t\t\t${Version}\n' 2>/dev/null ;;
        dnf)      rpm -qa --queryformat '%{NAME}\t\t\t%{VERSION}-%{RELEASE}\n' 2>/dev/null ;;
        pacman)   pacman -Q 2>/dev/null | sed 's/ /\t\t\t/' ;;
        zypper)   rpm -qa --queryformat '%{NAME}\t\t\t%{VERSION}-%{RELEASE}\n' 2>/dev/null ;;
        apk)      apk info -v 2>/dev/null | sed -E 's/(.*)-([0-9].*)/\1\t\t\t\2/' ;;
    esac
}

fetch_upgradeable() {
    case "$DETECTED_PM" in
        apt)      apt list --upgradeable 2>/dev/null | awk -F/ 'NR>1 && /-/{split($0,a," "); print $1 "\t\t\t" a[2]}' ;;
        dnf)      dnf list updates -q 2>/dev/null | awk 'NR>1 {match($1, /^([^.]+)/, n); print n[1] "\t\t\t" $2}' ;;
        pacman)   pacman -Qu 2>/dev/null | awk '{print $1 "\t\t\t" $4}' ;;
        zypper)   zypper list-updates 2>/dev/null | awk -F'|' 'NR>4{gsub(/ /,"",$3); gsub(/ /,"",$5); print $3 "\t\t\t" $5}' ;;
        apk)      apk version -u 2>/dev/null | sed -nE 's/^(.*)-([0-9].*) < (.*)/\1\t\t\t\3/p' ;;
    esac
}

show_info() {
    echo -e "${BOLD}${CYAN}Package Info:${RESET}\n"
    case "$DETECTED_PM" in
        apt)      apt-cache show "$1" 2>/dev/null | grep -Ev '^(Section:|Priority:|Installed|Essential:|SHA1:|SHA256:|SHA512:|MD5sum:|Description-md5:|Filename:|Size:|Task:)' ;;
        dnf)      dnf info "$1" 2>/dev/null ;;
        pacman)   pacman -Si "$1" 2>/dev/null || pacman -Qi "$1" 2>/dev/null ;;
        zypper)   zypper info "$1" 2>/dev/null ;;
        apk)      apk info -a "$1" 2>/dev/null ;;
    esac
}

show_help() {
    cat <<EOF
${BOLD}${BLUE}pmget${RESET} v${VERSION} - Package Manager Getter
https://github.com/gabrielmsilva00/pmget

${BOLD}Usage:${RESET}
  pmget                     Launch interactive TUI
  pmget -c [OPTIONS]        CLI mode
  pmget --self-install      Install/update pmget itself

${BOLD}Install pmget (one-liner):${RESET}
  curl -fsSL https://raw.githubusercontent.com/gabrielmsilva00/pmget/main/pmget | bash -s -- --self-install

${BOLD}Options:${RESET}
  -c, --cli                 CLI mode (non-interactive)
  -s, --sudo                Use sudo for operations
  -i PKG, --install PKG     Install packages (CLI mode)
  -r PKG, --remove PKG      Remove packages (CLI mode)
  --info PKG                Show package information
  --self-install [OPTS]     Install/update pmget itself
      --local               Install to ~/.local/bin (default)
      --usr                 Install to /usr/local/bin
      --root                Install to /root/.local/bin
  -v, --version             Show version
  -h, --help                Show this help

${BOLD}Examples:${RESET}
  pmget                          # Launch TUI
  pmget -c -s -i vim htop        # Install vim and htop with sudo
  pmget -c -r nano               # Remove nano
  pmget --info curl              # Show info for curl package
EOF
}

parse_args() {
    local mode=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--cli)     CLI_MODE=true ;;
            -s|--sudo)    USE_SUDO=true ;;
            -i|--install) mode="i" ;;
            -r|--remove)  mode="r" ;;
            -v|--version) echo "pmget v${VERSION}"; exit 0 ;;
            -h|--help)    show_help; exit 0 ;;
            --self-install) self_install "${@:2}"; exit 0 ;;
            --info)       detect_pm; show_info "$2"; exit 0 ;;
            *) [[ "$mode" == "i" ]] && INSTALL_PKGS+=("$1"); [[ "$mode" == "r" ]] && REMOVE_PKGS+=("$1") ;;
        esac
        shift
    done
}

run_cli() {
    echo "${BOLD}${BLUE}pmget${RESET} (${DETECTED_PM})$([[ "$USE_SUDO" == true ]] && echo " [sudo]")"
    local rc=0
    [[ ${#REMOVE_PKGS[@]} -gt 0 ]] && { echo "${RED}Removing:${RESET} ${REMOVE_PKGS[*]}"; run_pm remove "${REMOVE_PKGS[@]}" || rc=1; echo; }
    [[ ${#INSTALL_PKGS[@]} -gt 0 ]] && { echo "${GREEN}Installing:${RESET} ${INSTALL_PKGS[*]}"; run_pm install "${INSTALL_PKGS[@]}" || rc=1; }
    [[ ${#INSTALL_PKGS[@]} -eq 0 && ${#REMOVE_PKGS[@]} -eq 0 ]] && echo "${YELLOW}No packages selected${RESET}"
    exit $rc
}

# ----------------------------------------------------
# TUI Logic
# ----------------------------------------------------

run_tui() {
    echo -n "${WHITE}Loading packages...${RESET} "
    
    # Create a temp dir for all artifacts
    TMP_DIR=$(mktemp -d)
    PKG_FILE="$TMP_DIR/packages"
    STATE_FILE="$TMP_DIR/state"
    INST_FILE="$TMP_DIR/installed"
    UPGR_FILE="$TMP_DIR/upgradeable"
    MODE_FILE="$TMP_DIR/mode"
    HELPER_SCRIPT="$TMP_DIR/helper.sh"
    
    # Cleanup on exit
    trap "rm -rf '$TMP_DIR'; [[ -n \"${st_orig:-}\" ]] && stty \"\$st_orig\" 2>/dev/null; tput cnorm 2>/dev/null || true" EXIT INT
    
    # Sudo Auto-Detection (per user request)
    if [[ $EUID -eq 0 || "$USE_SUDO" == true ]]; then
        USE_SUDO=true
        echo "__SUDO__=true" >> "$STATE_FILE"
    fi
    
    touch "$STATE_FILE" "$INST_FILE" "$UPGR_FILE"
    echo "ALL" > "$MODE_FILE"
    
    fetch_packages > "$PKG_FILE"
    fetch_installed > "$INST_FILE"
    fetch_upgradeable > "$UPGR_FILE"
    
    if [[ ! -s "$PKG_FILE" ]]; then
        echo " ${RED}Failed!${RESET}"
        exit 1
    fi
    echo " ${GREEN}OK${RESET} ($(wc -l < "$PKG_FILE" | tr -d ' ') items)"

    # Generate Helper Script
    # Part 1: Static Variables (Unquoted Heredoc for Expansion)
    cat > "$HELPER_SCRIPT" <<EOF
#!/usr/bin/env bash
DETECTED_PM="$DETECTED_PM"
PM_PATH="$PM_PATH"

EOF

    # Part 2: Functions and Logic (Quoted Heredoc to protect awk/regex)
    cat >> "$HELPER_SCRIPT" <<'EOF'

_get_state() {
    awk -F= -v pkg="$2" '$1 == pkg {print $2}' "$1"
}

_set_state() {
    local sf="$1"
    local pkg="$2"
    local val="$3"
    awk -F= -v pkg="$pkg" -v val="$val" '
        $1 != pkg {print $0}
        END {print pkg "=" val}
    ' "$sf" > "$sf.tmp" && mv "$sf.tmp" "$sf"
}

_toggle_sudo() {
    local sf="$1"
    if grep -q "__SUDO__=true" "$sf"; then
        grep -v "__SUDO__=" "$sf" > "$sf.tmp"
        mv "$sf.tmp" "$sf"
    else
        echo "__SUDO__=true" >> "$sf"
    fi
}

_internal_state_mod() {
    local sf="$1" pkg="$2" dir="$3" inst_f="$4" upgr_f="$5"
    local s=$(_get_state "$sf" "$pkg")
    [[ -z "$s" ]] && s=0
    
    # Determine package status
    local is_inst=0 is_upgr=0
    awk -F'\t' -v p="$pkg" '$1==p{exit 0} END{exit 1}' "$inst_f" && is_inst=1
    awk -F'\t' -v p="$pkg" '$1==p{exit 0} END{exit 1}' "$upgr_f" && is_upgr=1
    
    local n=0
    if [[ "$dir" == "next" || "$dir" == "toggle_or_select" ]]; then
        if [[ $is_inst -eq 0 ]]; then
            [[ "$s" == "1" ]] && n=0 || n=1
        elif [[ $is_upgr -eq 1 ]]; then
            if [[ "$s" == "3" ]]; then n=2; elif [[ "$s" == "2" ]]; then n=0; else n=3; fi
        else
            [[ "$s" == "2" ]] && n=0 || n=2
        fi
    elif [[ "$dir" == "prev" ]]; then
        if [[ $is_inst -eq 0 ]]; then
            [[ "$s" == "1" ]] && n=0 || n=1
        elif [[ $is_upgr -eq 1 ]]; then
            if [[ "$s" == "2" ]]; then n=3; elif [[ "$s" == "3" ]]; then n=0; else n=2; fi
        else
            [[ "$s" == "2" ]] && n=0 || n=2
        fi
    fi
    _set_state "$sf" "$pkg" "$n"
}
 
_info() {
    local pm_name="$1"
    local pm_path="$2"
    local pkg="$3"
    echo -e "\033[1m\033[34mPackage Information:\033[0m\n"
    
    case "$pm_name" in
        apt)    apt-cache show "$pkg" 2>/dev/null | grep -Ev '^(Section:|Priority:|Installed|Essential:|SHA1:|SHA256:|SHA512:|MD5sum:|Description-md5:|Filename:|Size:|Task:)' ;;
        dnf)    "$pm_path" info "$pkg" 2>/dev/null ;;
        pacman) "$pm_path" -Si "$pkg" 2>/dev/null || "$pm_path" -Qi "$pkg" 2>/dev/null ;;
        zypper) "$pm_path" info "$pkg" 2>/dev/null ;;
        apk)    "$pm_path" info -a "$pkg" 2>/dev/null ;;
    esac
}

_internal_gen_list() {
    local pkg_file="$1"
    local state_file="$2"
    local inst_file="$3"
    local upgr_file="$4"
    local filter_mode="${5:-ALL}"
    local search_tag="${6:-}"
    
    awk -v state_file="$state_file" -v inst_file="$inst_file" -v upgr_file="$upgr_file" \
        -v filter_mode="$filter_mode" -v search_tag="$search_tag" '
    BEGIN {
        sudo_on = 0
        if (state_file != "") {
            while ((getline line < state_file) > 0) {
                split(line, parts, "=")
                if (parts[1] == "__SUDO__" && parts[2] == "true") sudo_on = 1
                if (parts[1] !~ /^__/) state[parts[1]] = parts[2]
            }
            close(state_file)
        }
        if (inst_file != "") {
            while ((getline line < inst_file) > 0) {
                split(line, parts, "\t")
                val = parts[2]; if (val == "") val = parts[4]
                installed[parts[1]] = val
            }
            close(inst_file)
        }
        if (upgr_file != "") {
            while ((getline line < upgr_file) > 0) {
                split(line, parts, "\t")
                val = parts[2]; if (val == "") val = parts[4]
                upgradeable[parts[1]] = val
            }
            close(upgr_file)
        }

        GREEN="\033[32m"; RED="\033[31m"; YELLOW="\033[33m"; BLUE="\033[34m"; MAGENTA="\033[35m"
        CYAN="\033[36m"; GREY="\033[90m"; WHITE="\033[97m"; BOLD="\033[1m"; RESET="\033[0m"
        
        # Header and Legends (first field is dummy for --with-nth=2)
        n_inst=0; n_rem=0; n_upgr=0
        for (p in state) {
            if (state[p] == "1") n_inst++
            else if (state[p] == "2") n_rem++
            else if (state[p] == "3") n_upgr++
        }
        
        printf "_\t%s%s  SUDO: %s%s%s%s\n", BOLD, YELLOW, RESET, BOLD, (sudo_on ? GREEN "ON" : RED "OFF"), RESET
        printf "_\t%s%s  SELECTED: %sInstall: %s%d%s | Remove: %s%d%s | Upgrade: %s%d%s\n", BOLD, BLUE, WHITE, (n_inst>0?GREEN:WHITE), n_inst, WHITE, (n_rem>0?RED:WHITE), n_rem, WHITE, (n_upgr>0?BLUE:WHITE), n_upgr, RESET
        printf "_\t%s%s  KEYS: %s%s(Tab: Sudo | ←/→/Space: Cycle | Enter: Apply | Esc: Exit)%s\n", BOLD, CYAN, RESET, WHITE, RESET
        printf "_\t%s%s  SYMBOLS: %s%s[ ] None  [✓] Inst [+] Add  [-] Rem  [↑] Upgr%s\n", BOLD, MAGENTA, RESET, WHITE, RESET
    }
    {
        split($0, arr, "\t")
        pkg = arr[1] 
        val = arr[2]; if (val == "") val = arr[4]
        display = (val == "" ? pkg : val)
        
        s = state[pkg]; is_inst = (pkg in installed); is_upgr = (pkg in upgradeable)
        
        # Filtering
        if (filter_mode == "INSTALLED" && !is_inst) next
        if (filter_mode == "UPGRADEABLE" && !is_upgr) next
        
        sym = "[ ]"; col = RESET; rst = RESET; ver_info = ""
        
        if (s == "1") { sym = "[+]"; col = BOLD GREEN }
        else if (s == "2") { sym = "[-]"; col = BOLD RED }
        else if (s == "3") { sym = "[↑]"; col = BOLD CYAN }
        else if (is_upgr) { 
            sym = "[^]"; col = BOLD YELLOW 
            ver_info = YELLOW installed[pkg] RESET " → " GREEN upgradeable[pkg] RESET
        }
        else if (is_inst) { 
            sym = "[✓]"; col = BOLD BLUE 
            ver_info = GREY installed[pkg] RESET
        }
        
        # Display [sym] pkg-name (tab) ver_info (tab) display (tab) magic_tag
        suffix = (search_tag != "" ? "\t" search_tag : "")
        printf "%s\t%s%s %s%s\t\t\t%s\t%s%s%s\n", pkg, col, sym, pkg, rst, ver_info, display, rst, suffix
    }
    ' "$pkg_file"
}

_internal_smart_reload() {
    local query="$1"
    local force="$2"
    local mode_file="$3"
    local pkg_file="$4"
    local state_file="$5"
    local inst_file="$6"
    local upgr_file="$7"
    
    local current_mode="ALL"
    [[ -f "$mode_file" ]] && current_mode=$(<"$mode_file")
    
    local target_mode="ALL"
    local tag=""
    
    if [[ "$query" == ":-i"* ]]; then
        target_mode="INSTALLED"
        tag=":-i"
    elif [[ "$query" == ":-u"* ]]; then
        target_mode="UPGRADEABLE"
        tag=":-u"
    fi
    
    if [[ "$force" != "force" && "$target_mode" == "$current_mode" ]]; then
        exit 1
    fi
    
    echo "$target_mode" > "$mode_file"
    _internal_gen_list "$pkg_file" "$state_file" "$inst_file" "$upgr_file" "$target_mode" "$tag"
}

case "$1" in
    gen-list)     _internal_gen_list "$2" "$3" "$4" "$5" "$6" "$7" ;;
    update-state) _internal_state_mod "$2" "$3" "$4" "$5" "$6" ;;
    toggle-sudo)  _toggle_sudo "$2" ;;
    info)         _info "$DETECTED_PM" "$PM_PATH" "$2" ;;
    smart-reload) _internal_smart_reload "$2" "$3" "$4" "$5" "$6" "$7" "$8" ;;
esac
EOF
    
    # Define Commands using bash to execute the helper script
    # Field 1 is the package ID (always clean), Field 2+ is for display.
    local helper_cmd="bash '$HELPER_SCRIPT'"
    
    # We use smart-reload with force for manual actions
    local cmd_force_reload="$helper_cmd smart-reload \"{q}\" force '$MODE_FILE' '$PKG_FILE' '$STATE_FILE' '$INST_FILE' '$UPGR_FILE'"
    # We use smart-reload without force for typing
    local cmd_typing_reload="$helper_cmd smart-reload \"{q}\" normal '$MODE_FILE' '$PKG_FILE' '$STATE_FILE' '$INST_FILE' '$UPGR_FILE'"

    local cmd_update_next="$helper_cmd update-state '$STATE_FILE' '{1}' next '$INST_FILE' '$UPGR_FILE'"
    local cmd_update_prev="$helper_cmd update-state '$STATE_FILE' '{1}' prev '$INST_FILE' '$UPGR_FILE'"
    local cmd_toggle="$helper_cmd update-state '$STATE_FILE' '{1}' toggle_or_select '$INST_FILE' '$UPGR_FILE'"
    local cmd_preview="$helper_cmd info '{1}'"

    # Enter Non-canonical mode to prevent escape sequence leakage (per user insight)
    if [[ -t 0 ]]; then
        st_orig=$(stty -g)
        stty -icanon -echo
    fi
    tput civis 2>/dev/null || true
    
    # TUI Loop with confirmation flows
    local fzf_exit_code=0
    while true; do
        # Always reset mode to ALL on loop restart (fzf restart)
        echo "ALL" > "$MODE_FILE"
        
        # Initial Generation
        bash "$HELPER_SCRIPT" gen-list "$PKG_FILE" "$STATE_FILE" "$INST_FILE" "$UPGR_FILE" | \
        fzf --ansi --no-multi \
            --prompt="${BLUE}pmget> ${RESET}" \
            --delimiter=$'\t' \
            --with-nth=2,5 \
            --header-lines=4 \
            --tiebreak=begin,index \
            --preview="$cmd_preview" \
            --preview-window="top:30%" \
            --layout=reverse \
            --info=inline \
            --no-bold \
            --bind "change:reload($cmd_typing_reload || true)" \
            --bind "right:reload($cmd_update_next && $cmd_force_reload)" \
            --bind "left:reload($cmd_update_prev && $cmd_force_reload)" \
            --bind "space:reload($cmd_toggle && $cmd_force_reload)" \
            --bind "tab:reload($helper_cmd toggle-sudo '$STATE_FILE' && $cmd_force_reload)" \
            --bind "enter:accept" \
            > /dev/null
        
        fzf_exit_code=$?
        
        # Reset terminal temporarily for prompts
        # [[ -n "${st_orig:-}" ]] && stty "$st_orig" 2>/dev/null || true
        tput cnorm 2>/dev/null || true
        
        # Handle Esc (exit code 130 or 1)
        if [[ $fzf_exit_code -ne 0 ]]; then
            # Calculate pending changes from state file
            local n_inst=$(grep -c '=1$' "$STATE_FILE" 2>/dev/null)
            local n_rem=$(grep -c '=2$' "$STATE_FILE" 2>/dev/null)
            local n_upgr=$(grep -c '=3$' "$STATE_FILE" 2>/dev/null)

            # If no changes pending, exit immediately
            if [[ "$n_inst" -eq 0 && "$n_rem" -eq 0 && "$n_upgr" -eq 0 ]]; then
                echo
                return 0
            fi

            echo
            echo "${YELLOW}Exit without changes?${RESET}"
            echo "Selected: ${GREEN}$n_inst${RESET} Install, ${RED}$n_rem${RESET} Remove, ${BLUE}$n_upgr${RESET} Upgrade"
            echo -n "  Press ${BOLD}Enter/Space${RESET} to return, ${BOLD}any other key${RESET} to exit: "
            
            # Read single keypress
            local key
            read -rsn1 key
            
            if [[ -z "$key" || "$key" == " " ]]; then
                # Enter or Space pressed - go back to TUI
                echo
                # Restore non-canonical mode for fzf
                if [[ -t 0 ]]; then
                    stty -icanon -echo
                fi
                tput civis 2>/dev/null || true
                continue
            else
                # Any other key (including Esc) - exit
                echo
                echo "${CYAN}Exited without changes.${RESET}"
                return 0
            fi
        fi
        
        # Handle Enter - show confirmation
        if grep -q "__SUDO__=true" "$STATE_FILE"; then
            USE_SUDO=true
        else
            USE_SUDO=false
        fi

        local inst=$(grep '=1$' "$STATE_FILE" 2>/dev/null | cut -d= -f1 | tr '\n' ' ')
        local rem=$(grep '=2$' "$STATE_FILE" 2>/dev/null | cut -d= -f1 | tr '\n' ' ')
        local upgr=$(grep '=3$' "$STATE_FILE" 2>/dev/null | cut -d= -f1 | tr '\n' ' ')
         
        if [[ -z "$inst" && -z "$rem" && -z "$upgr" ]]; then
             echo
             echo "${YELLOW}No packages selected${RESET}"
             return 0
        fi

        # Show summary and ask for confirmation
        echo
        echo "${BOLD}${WHITE}Pending Changes:${RESET}"
        [[ -n "$inst" ]] && echo "  ${GREEN}Install:${RESET} $inst"
        [[ -n "$rem" ]] && echo "  ${RED}Remove:${RESET} $rem"
        [[ -n "$upgr" ]] && echo "  ${BLUE}Upgrade:${RESET} $upgr"
        [[ "$USE_SUDO" == true ]] && echo "  ${YELLOW}Sudo:${RESET} enabled"
        echo
        echo -n "Press ${BOLD}Enter${RESET} to proceed, ${BOLD}Esc${RESET} to go back: "
        
        # Read single keypress
        local key
        read -rsn1 key
        
        if [[ -z "$key" ]]; then
            # Enter pressed - proceed with execution
            echo
            break
        else
            # Any other key (including Esc) - go back to TUI
            echo
            # Restore non-canonical mode for fzf
            if [[ -t 0 ]]; then
                stty -icanon -echo
            fi
            tput civis 2>/dev/null || true
            continue
        fi
    done
    
    # Reset terminal
    [[ -n "${st_orig:-}" ]] && stty "$st_orig" 2>/dev/null || true
    tput cnorm 2>/dev/null || true
    
    # Execute changes
    echo
    local cmd="pmget -c"
    [[ "$USE_SUDO" == true ]] && cmd+=" -s"
    [[ -n "$inst" ]] && cmd+=" -i $inst"
    [[ -n "$rem" ]] && cmd+=" -r $rem"
    # Upgrades are treated as installs (package managers handle upgrades via install)
    [[ -n "$upgr" ]] && cmd+=" -i $upgr"
     
    echo "${WHITE}> Executing...${RESET}"
    eval "$cmd"
    exit 0
}

main() {
    parse_args "$@"
    detect_pm
    [[ "$CLI_MODE" == true ]] && run_cli || run_tui
}

main "$@"
